---
layout: post
title: "做比赛记录II——solution"
category: "solution"
tags: ["solution" ,"life"]
---
{% include JB/setup %}

题挺不错的，还是写写题解吧。虽然BG没过，懒得写了。lyp把这一套都做完了，好像很厉害的样子。

##B##

题意见ayq的集训队作业。ayq给了一个分块的搞法，clj给过一个基于完全动态凸包的做法。

我脑补了一个好像比较好实现的O(nlog^2n)-O(log^2n)的做法，首先建一棵线段树，对于一个区间\[l,r\]，我们从mid向左搞，mid+1向右搞凸壳，这是一个可持久化栈，就是一个树形的结构。然后同时搞出\[x,mid\]或\[mid+1,x\]的答案，这一步可以直接从\[x+1,mid\]搞过来，然后二分x和\[x+1,mid\]的最大斜率。然后倍增建树。询问放到线段树中，会在某一时刻变成\[l,mid\],\[mid+1,r\]，那么我们可以二分套二分，由于倍增建树，所以二分还是能搞的。

理论上上面那个东西是能被优化到O(nlogn)-O(logn)的。首先考虑询问，可以直接同时在两个上一起二分，见clj的集训队作业。然后树上某一深度祖先也存在O(n)-O(1)的搞法，所以不用倍增建树了。然后考虑怎么从\[x+1,mid\]得到\[x,mid\]，对于\[x+1,mid\]，我们可以拆成\[x+1,p\],\[p+1,mid\]，其中\[p+1,mid\]是一个线段树节点，\[x,mid\]是\[p+1,mid\]的父节点的一个子区间，那么\[x,mid\]就是\[x,p\],\[p+1,mid\]，然后区间\[x,p\]的凸壳和\[p+1,mid\]的公切线。所以变成每次在左边凸壳的左边加一个点，然后维护公切线，这个是有单调性的，然后就能线性搞了。

我怀疑每个深度保留二进制末尾零个数个祖先，就能在树上二分了。

##D##

这是一个比较有意思的题目。对于一个长度为L的01串集合，可以建出唯一最小状态DFA，能且只能识别这些01串。然后指定一个01串集合，使得最小状态DFA的节点尽量多，然后要让这个01串集合尽量小。

虽然不是很难但还是一个挺有意思的题目，而且我看毛子很多队都过了，感觉毛子好屌啊。最好先不要看题解自己想一下。

首先这个DFA是一个分层图，然后第i层的节点数不超过2^i个，这是显然的。然后第L层就是汇点了，考虑倒数第二层最多只有三种状态，只能识别0，只能识别1，能识别01。所以第i层，最多只有2^(2^(L-i))-1个结点。就是共有2^(L-i)个01串，每个结点分别能不能识别这2^(L-i)个子串，所以总共2^(2^(L-i))的状态，去掉什么都不能识别的点。然后第i层的节点数就是min(2^(2^(L-i))-1,2^i)这显然是充要的。

很不幸，又烂尾了。
---
layout: post
title: "Topcoder-500-509-hard"
category: "solution"
tags: ["Topcoder", "solution"]
---
{% include JB/setup %}

其实都是有题解的。写一下mark一下，有些不是自己想出来的题目会忘的。

#500

应该是一个挺简单的题。枚举某些数字，算出其他数字，然后排列组合算一下就好了。

#501

做了后还是不怎么会。看了代码发现是抄Petr的。而且翻了一下没发现题解。

首先考虑dp[i][k]表示走到第i个宝藏，然后左右走了k步最大的收获，通过这个状态可以算出时间。考虑转移，同行之间就是左右扫一遍，然后上下行之间，从左边转移过来满足x[i']-k'=x[i]-k，然后x[i']<=x[i]的最大值，这样就是维护若干个树状数组就可以了。

#502

rng_58的神题，第一眼看到这个题总会想起生成函数，单位根什么的，其实什么关系都没有。于是我去翻下题解。

有k个数，先考虑顺序，并固定了前k-1个数，那么最后一个数有唯一的取值使得这k个数的和被n整除，减去最后一个数重复出现的方案数。也就是`x_1+x_2+x_3+...+2*x_{k-1}=0 (mod n)`。

考虑一般问题`x_1+x_2+x_3+...+a*x_k=0 (mod n)`的每个数不同解数，总的方案是规约到前k-1个数，然后要保证被(n,a)整除，再乘上最后有可能的x_k解数，然后再减去x_k重复的。这样就能写出递归式。

最后答案除掉k的阶乘，然后保证顺序。

#503

想法很简单，就是棋盘分割。但代码好像长了点。挺多人包括作者都是分了几种情况做的。推荐rng_58的代码，直接当成一个八边形做。这样就能统一所有的情况，思路比较清晰。

#504

也是很简单的一个题目，首先要看懂题面是什么意思，然后考虑一段可行的充要条件。最后注意全是`A`的情况。

#505

考虑三种pattern，一种有一个0，然后总和和乘积都是0，第二种是`(1,-1,1,-1)_n ,x`，不属于前面两种模式可以证明积的绝对值不超过100，然后就直接dp

#506

非常诡异的题。那个正确性感觉很显然，但又怀疑这个为什么是对的。

#507

计数dp，先算那个每一行，然后再算一个面就好了。

#508

我看懂题解后在看懂题目，首先二分，然后和每条线段截一下，然后判断可行时候使用Hall定理非常巧妙，当然直接网络流可以。

#509

简单的计数，去掉时候常见的手段就是枚举第一个点，然后就要算两点之间不经过其他点的数目，然后容斥搞一下就好了。

#summary

通过做TC能发现我有多弱了，大概就是码题比别人想+码还要慢。手速很慢，然后debug比写还要慢，想的也很慢，hard题想出来后也码不出来，或者有好多好多bug。总而言之就是代码能力太差，智商不行。智商不行就没得救了。
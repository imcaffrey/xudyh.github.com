---
layout: post
title: "Broken Keys"
category: "solution"
tags: ["solution"]
---
{% include JB/setup %}

除草，这几天好像没怎么干正事。

用hvm不用 ?:/- 四个符号比较两个byte之内数的最大值。

?就是比较两个数的大小，:比较和0是否相同。

不用?显然从大到小枚举就行了然后用:及时判断break就行了。

不用:，我们能用/-，就是把i>=1的，Mem[i]搞成b,答案就是Mem[b/a]，由于某些原因，b/a不会很大，因为不能判断，所以很难直接搞循环，把这段代码复制几遍就行了。

不用/，其实-和/是差不多的。。。就是把i>=0，Mem[i]搞成a,i<0的Mem[i]搞成b，缩一下代码。。。然后直接复制256遍还是太长，然后减短一点，这样就不能保证正确性了。然后刷几遍就过了。

不用-，这意味着剩下的运算都是满足交换律的，所以要换一个方向想。所以搞个权值*c+d，然后对于i!=a,b c[i]=1,d[i]=0,否则c[i]=0,d[i]=i，但是这样代码太长了。复制256遍是不能过的。所以我们要用黑技术模拟循环，就是一开始把程序的运行顺序压倒栈里面，比如压16个，然后每块做16边，然后跳转到当前程序的块头，当然栈最下面一个跳到下一部分或终结条件。然后就搞好了。

	00 1^<0^0:1-6?779**c 0^68*:1+0:1-48*?1v0^0:6 ?2v2v1gd 356**c 1+03c   68*-1v25**+1v1+1v3c   0^58*:1-46*?99*<>99*<1+99*>345**c    11^59*2+:*1^67*:*9?569**c        199*<0:*0^58*?99*<1-<58*:*99*<1-<59*:*99*<1-<59*2-:*   28*?458**999**c     99*<>99*<1+99*>345**c             11^59*:*1^59*2-:*9?688**c       199*<0:*0^35*?99*<1-<58*:*    28*?569**999**c     99*<>99*<1+99*>345**c             99*<1-<58*: 28*?688**999**c       99*<1-99*>d345**c    d0^3?1v0            99*<28*?779**29*+999**c        ddp!                                                                                                                                                                                                                                           4v4v99*<1-<0^59*2+:4?97+gd/3v3v3v4666***c 0^59*:4?97+gd-3v3v3v4666***c 0^59*2-:4?97+gd+3v3v3v4666***c 0^59*3-:4?97+gd*3v3v3v4666***c   99*<1-99*>c

啥，你会写表达式计算吗？
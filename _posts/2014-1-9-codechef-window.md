---
layout: post
title: "Codechef WINDOW"
category: "solution"
tags: ["solution"]
---
{% include JB/setup %}

这是我认为CC上挺不错的题之一。其他的还有CHANGE,QPOLYSUM。我觉得强烈推荐这三个题。

不错的数学题还有CIELHACK这个题非常奇葩，渐进求和，避免误差什么的，不是很合我口味。所以就不做了。

还有待补的就是PARSIN的生成函数解法和一个奇葩做法。

感觉在三个题中，这个题应该是最简单的了吧。其他题我的用时好像遥遥领先，这个题跑了3s+，仅次于ACRush，感觉这个题目做法比较单一，复杂度上很难有提高。

简单讲一下题解，官方的题解不知道在写什么，一个O(s^4logn)的居然能过，我看了一下代码好像都是O(s^3logn)的。然后由于不是很清楚其他人是怎么做的，所以不敢保证这个思路原创。然后看了一下周教的冬令营课件，好像写了一个O(s^4logn)的就烂尾了，或者说我很难发现这个是O(s^3logn)的。然后贾教的题解感觉基本上是炫技，然后我就没看。

首先一个基本的两个求和的指标互换，注意一下范围，然后做一下abel变换，变成一个差分，一个求和，直接用多项式表示这个展开有O(s^2)项，然后我没想到什么太好的方法。好像通过一些暴力推导能得到基本相同的结论。然后我的想法是维护形如sigma(binom(x,u)\*binom((ax+b)/c,v))的式子，这样这一部分能在O(1)内实现，但发现化a>=c,b>=c时展开就变O(s^2)了。我想了好久都没有相到一些好的方法，当然fft应该能做到O(s^2log^2s)。

于是我们还是维护sigma(pow(x,u)\*pow((ax+b)/c,v))，然后可以在总时间O(s^3)内转化成sigma(pow(x,u)\*binom((ax+b)/c,v))，然后一维差分用二项式定理直接展开，一维求和，每一个能在O(s)内解决，然后在O(s^3)内转回sigma(pow(x,u)\*pow((ax+b)/c,v))。这样的思路还是挺清晰的，不涉及太烦的推导（主要在abel变换了。。。整除考虑范围实在讨厌），然后所涉及到最深的知识大概就是二项式定理了。那些系数什么的可以直接暴力插值，只是常数大了点，不用算什么第一类第二类Stirling数了。这个方法好像常数也不是很大。

后来我发现直接搞二项式也能通过先变成一个二项式乘一个多项式，然后就能搞了，好像常数会更好一点。但是我懒得管了。

做完这个题感觉还是爽的。